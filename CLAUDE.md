# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Scotty is a Rust-based Micro-PaaS (Platform as a Service) that provides an API to manage Docker Compose-based applications. It consists of three main components:

- **scotty**: HTTP server providing REST API and web UI for managing applications
- **scottyctl**: CLI application for interacting with the Scotty server  
- **scotty-core**: Core library containing shared data structures and settings

## Architecture

Scotty manages applications by:
1. Scanning a configurable apps directory for folders containing `docker-compose.yml` files
2. Reading optional `.scotty.yml` configuration files for app-specific settings
3. Generating `docker-compose.override.yml` files with load balancer configurations (Traefik or HAProxy)
4. Managing app lifecycle (create, start, stop, destroy) with TTL-based auto-cleanup
5. Supporting app blueprints for common deployment patterns

### Authentication Modes

Scotty supports three authentication modes (configured via `auth_mode`):
- **Development**: No authentication required, uses fixed dev user
- **OAuth**: Authentication via oauth2-proxy with GitLab OIDC integration  
- **Bearer**: Traditional token-based authentication

Authentication is handled by the `basic_auth.rs` middleware which extracts user information based on the configured mode.

## Development Commands

### Building and Running

```bash
# Build all workspace members
cargo build

# Run the scotty server
cargo run --bin scotty

# Run the scottyctl CLI
cargo run --bin scottyctl -- help

# Run with specific configuration
SCOTTY__API__AUTH_MODE=dev cargo run --bin scotty
```

### Frontend Development

The frontend is a SvelteKit application with TypeScript:

```bash
cd frontend

# Install dependencies (use bun instead of npm)
bun install

# Run development server  
bun run dev

# Build for production
bun run build

# Lint and format
bun run lint
bun run format
```

### Testing and Quality

```bash
# Run tests for all workspace members
cargo test

# Run tests for specific crate
cargo test -p scotty-core

# Check formatting
cargo fmt --check

# Run clippy linting
cargo clippy --all-targets --all-features
```

### Release Management

```bash
# Update changelog using git-cliff
git cliff > CHANGELOG.md

# Create new release (example for alpha)
cargo release --no-publish alpha -x --tag-prefix ""
```

## Configuration Structure

### Main Configuration Files
- `config/default.yaml`: Base configuration with all settings
- `config/local.yaml`: Local overrides for development
- `config/blueprints/`: App blueprint definitions (drupal-lagoon.yaml, nginx-lagoon.yaml)

### OAuth Development Setup
The `examples/oauth2-proxy/` directory contains a complete OAuth development environment:

```bash
cd examples/oauth2-proxy

# Start in development mode (no auth)
./start-dev.sh dev

# Start with OAuth (requires GitLab app configuration)  
op run --env-file="./.env.1password" -- ./start-dev.sh oauth --build

# Start in bearer token mode
./start-dev.sh bearer
```

### Key Configuration Options

- `auth_mode`: "dev", "oauth", or "bearer"
- `bind_address`: Server bind address (default: "0.0.0.0:21342")
- `apps.root_folder`: Directory to scan for applications
- `load_balancer_type`: "Traefik" or "HaproxyConfig"
- `traefik.network`: Docker network for Traefik integration
- `docker.registries`: Private Docker registry configurations

## App Management

### App Types
- **Owned**: Fully managed by Scotty, can be destroyed
- **Supported**: Can be managed but not destroyed
- **Unsupported**: Read-only, shown in UI but not manageable

### App Structure
```
apps/
├── my-app/
│   ├── docker-compose.yml          # Required
│   ├── .scotty.yml                 # Optional app settings  
│   ├── docker-compose.override.yml # Generated by Scotty
│   └── ... (other app files)
```

### Blueprints
Blueprints provide common deployment patterns and are referenced during app creation. They define lifecycle hooks that execute at specific events (create, run, destroy).

## API and CLI Integration

The API is self-documenting via OpenAPI/Swagger at `/rapidoc` endpoint. The CLI (`scottyctl`) communicates with the server via this REST API using bearer token authentication.

Key environment variables for CLI:
- `SCOTTY_SERVER`: Server URL
- `SCOTTY_ACCESS_TOKEN`: Authentication token

## Load Balancer Integration

Scotty generates appropriate configurations for:

### Traefik (Preferred)
- Uses Docker labels for service discovery
- Supports custom middlewares, basic auth, robots.txt prevention
- Automatic SSL via Let's Encrypt integration

### HAProxy-Config (Legacy)  
- Uses environment variables for configuration
- Limited feature set compared to Traefik

## Development Notes

- Use workspace-level Cargo.toml for shared dependencies
- Frontend uses Bun instead of npm for package management  
- Conventional commits are enforced via git-cliff
- Pre-push hooks via cargo-husky perform quality checks
- Container apps directory must have identical paths on host and container for bind mounts
- Use conventional commit messages
- Please check your code with `cargo fmt` and `cargo clippy`

## Current Work in Progress

### Unified Output System Implementation ✅ COMPLETED (Phase 3.5)

**Branch:** `feat/better-logs-and-shell`

**Status: Core functionality complete with consolidated WebSocket messages**

### Phase 1 Completed:
- ✅ Unified output data model (OutputLine, TaskOutput, OutputStreamType)
- ✅ Breaking change: removed stdout/stderr from TaskDetails
- ✅ Updated TaskManager for unified output collection
- ✅ Added configuration options (OutputSettings, ShellSettings)
- ✅ Extended WebSocket message types for logs and shell
- ✅ Fixed client-visible status messages

### Phase 2 Completed:
- ✅ Implemented bollard log streaming service with LogStreamingService
- ✅ Implemented bollard shell service with ShellService
- ✅ Added helper methods to AppData for container discovery
- ✅ Improved error handling with enum-based errors (LogStreamError, ShellServiceError)
- ✅ Created API endpoints for logs and shell access
- ✅ Integrated endpoints into router with appropriate permissions
- ✅ Added comprehensive tests (16 tests total) with CI-friendly Docker handling
- ✅ All tests passing, GitHub Actions CI ready

### Phase 3 Completed:
- ✅ **CLI Commands**: Implemented full `app:logs` and `app:shell` commands in scottyctl
- ✅ **WebSocket Integration**: Added WebSocket handlers in message_handler.rs for real-time streaming
- ✅ **Authentication System**: Centralized auth logic in auth_core module, eliminating duplication
- ✅ **Stream Cleanup**: Added proactive client disconnect cleanup for proper resource management
- ✅ **User Experience Improvements**:
  - Reduced idle timeout from 2s to 200ms for faster historical log completion
  - Removed duplicate completion messages for cleaner output
  - Changed timestamps to opt-in with `--timestamps` flag (default: disabled)
- ✅ **WebSocket Authentication**: Implemented message-based authentication flow
- ✅ **Example App**: Added log-demo example app for testing and development
- ✅ **End-to-End Testing**: Verified complete functionality with real containers

### Phase 3.5 Completed:
- ✅ **WebSocket Message Consolidation**: Moved all WebSocket message types to `scotty-core/src/websocket/message.rs`
- ✅ **Code Restructuring**: Reorganized API handlers into `api/rest/` and `api/websocket/` directories
- ✅ **Type Consistency**: Eliminated duplicate message definitions between server and client
- ✅ **Import Updates**: Updated 18 files to use consolidated message types from scotty-core
- ✅ **Quality Assurance**: All tests pass, no compilation errors, proper code formatting

### Phase 3.6 Completed:
- ✅ **Task Output WebSocket Streaming**: Implemented real-time task output streaming via WebSocket
- ✅ **Unified Output Display**: Live stdout/stderr output during all app operations
- ✅ **Hybrid Implementation**: Combined REST API polling for task status with WebSocket for real-time output
- ✅ **WebSocketMessenger Architecture**: Centralized WebSocket client management and message broadcasting
- ✅ **Stack Overflow Resolution**: Fixed circular reference issues in TaskManager data structures
- ✅ **Resource Cleanup**: Proper WebSocket subscription cleanup during task completion

### Future Phase (Phase 4 - Frontend Integration):
- Replace current stdout/stderr UI components with unified output viewer
- Use WebSocket-only approach for task output (no REST endpoints)
- Add real-time WebSocket task output streaming to web UI
- Display output in chronological order with stream type indicators
- Polish user experience, loading states, and error handling in frontend

### Key Commands Available:
```bash
# Log streaming with various options
scottyctl app:logs myapp web                    # Historical logs
scottyctl app:logs myapp web --follow           # Real-time streaming
scottyctl app:logs myapp web --timestamps       # With timestamps
scottyctl app:logs myapp web --lines 500        # Custom line count

# Interactive shell access
scottyctl app:shell myapp web                   # Interactive bash shell
scottyctl app:shell myapp web --user www-data   # As specific user
scottyctl app:shell myapp web --shell /bin/sh   # Different shell
```

### Key Files Added/Modified (All Phases):
- `scotty-core/src/websocket/message.rs` - **NEW**: Consolidated WebSocket message types
- `scotty-core/src/websocket/mod.rs` - **NEW**: WebSocket module exports
- `scotty/src/api/auth_core.rs` - Centralized authentication logic
- `scotty/src/api/rest/handlers/` - **RESTRUCTURED**: REST API handlers organized by protocol
- `scotty/src/api/websocket/handlers/` - **RESTRUCTURED**: WebSocket handlers (auth, logs, tasks)
- `scotty/src/docker/services/logs.rs` - Complete log streaming implementation
- `scotty/src/docker/services/shell.rs` - Complete shell service implementation
- `scotty/src/api/websocket/client.rs` - WebSocket client management and cleanup (formerly ws.rs)
- `scotty/src/app_state.rs` - Shared LogStreamingService integration
- `scottyctl/src/commands/apps/logs.rs` - CLI log streaming command (now uses consolidated types)
- `scottyctl/src/commands/apps/shell.rs` - CLI shell access command
- `examples/log-demo/` - Demo application for testing

### Key Files Modified (Phase 3.6):
- `scotty/src/api/websocket/messaging.rs` - **NEW**: WebSocketMessenger abstraction for client management
- `scotty/src/tasks/manager.rs` - Refactored to use WebSocketMessenger for output broadcasting
- `scotty/src/app_state.rs` - Updated to create and share WebSocketMessenger instance
- `scottyctl/src/api.rs` - Hybrid approach: REST polling + WebSocket streaming for wait_for_task
- `scottyctl/src/websocket.rs` - **NEW**: Reusable WebSocket utilities and AuthenticatedWebSocket struct

### Latest Commits (All Phases):
- `71d155e` - feat(websocket): implement real-time task output streaming for Phase 3.6
- `b220730` - docs: update PRD and CLAUDE.md for Phase 3.5 completion
- `ee1875d` - refactor(websocket): consolidate message types in scotty-core (Phase 3.5 complete)
- `4606adc` - refactor(api): restructure handlers into REST and WebSocket modules
- `afad796` - feat(websocket): implement unified task output streaming system
- `b4be84c` - feat(cli): improve log command UX and add terminal detection

### Reference Documents:
- `docs/prds/unified-output-system.md` - Complete PRD and technical specifications
- `docs/technical-spike-bollard-findings.md` - Bollard API validation results
- the build files of scotty_frontend will be embedded into scotty, so restart scotty after the frontend files got rebuilt